\input{preambula}

\newcommand{\ma}{\displaystyle}

\begin{document}
	\title{Отчёт по задаче Рюкзак}
	\author{Сапожников Денис}
	\date{}
	\maketitle
	Я написал удобный класс Knapsack со множество методов:
	\begin{itemize}
		\item solve\_recover\_dp$(W)$ --- решает рюкзак методом ДП и восстанавливает ответ техникой divide-and-conqueror. $O(nW)$ времени, $O(n)$ памяти.
		\item solve\_recover\_meet\_in\_the\_middle$(W)$ --- решает рюкзак методом meet-in-the-middle. $O(n2^{\frac{n}{2}})$ времени и памяти.
		\item solve\_recover\_branch\_bound$(W)$ --- решает рюкзак методом Branch\&Bound. $O(2^n)$ времени в худшем случае. Верхняя граница считается $\frac{1}{2}$-аппроксимацией. Порядок предметов -- по стоимости. Порядок ветвей -- если взять предмет + $\frac{1}{2}$-аппроксимация больше, чем не взять + аппроксимация, то сначала идём в ветвь, где берём предмет, иначе -- сначала в ветвь, где не берём.
		\item solve\_recover\_approximation\_half$(W)$ --- половинная аппроксимация с лекции.
		\item solve\_recover\_approximation\_slow$(W, \varepsilon)$ --- первый медленный алгоритм $\varepsilon$-аппроксимации, работает за $O(n \log n + \frac{n^2}{\varepsilon})$, взят с лекции.
		\item solve\_recover\_approximation\_ibarra$(W, \varepsilon)$ --- алгоритм Ибарры $\varepsilon$-аппроксимации, за $O(n \log n + \frac{n}{\varepsilon^2})$, взят с лекции.
		\item solve\_recover\_on\_center\_optimization$(W, kL, kR, middle\_solver, *args)$. 
		
		Предположительно, оптимальный ответ устроен очень просто, если отсортировать все предметы по удельной стоимости $\frac{c}{w}$: $[\underbrace{1, 1, \ldots, 1}_{левая\ часть}, \underbrace{1, 0, 0, 1, \ldots, 1}_{центральная\ часть}, \underbrace{0, 0, \ldots, 0}_{правая\ часть}]$. Пусть $m_{half}$ --- граница $\frac{1}{2}$-аппроксимации, тогда выберем границы центральной части как $[m_{half} - kL; m_{half} + kR]$ и отправим этот набор предметов в \\
		$middle\_solver(W - w_{left}, *args)$. 
	\end{itemize}
	
	\textbf{Результаты экспериментов:}
	
	Потестовые результаты экспериментов доступны в приложенном csv-файле. 
	\begin{itemize}
		\item Техника Branch\&Bound работала очень долго даже при $n=30$, поэтому этот эксперимент вышел неудачным. Возможно, стоило хорошо аппроксимировать начальное приближение, чтобы отсечь много веток сразу, но я не успел попробовать.
		
		\item Как оказалось, медленный алгоритм аппроксимации давал результат лучше, чем алгоритм Ибарры при одном и том же $\varepsilon$ (и даже при больших $\varepsilon$). 
		
		\item Алгоритм с оптимизацией блока по центру вышел лучше всех, и стал выдавать хорошие результаты даже при meet-in-the-middle с параметрами $kL=15, kR=30$. 
		
		Техника Branch\&Bound работала долго и в центральной оптимизации. 
		
		Но вот медленная аппроксимация выдала очень хорошие результаты, и итоговое решение выделяет блок по центру с параметрами $kL=100, kR=500$ и аппроксимирует его с точностью $0.05\%$. Кроме того, было замечено, что при меньших границах иногда результат бывает лучше, поэтому запускается ещё и центральная оптимизация с параметрами $kL=50, kR=250$ и точностью $0.05\%$. Ну и для уверенности в себе ещё запускается алгоритм Ибарры с точностью $5\%$ (меньшие значения работали так же по приближению, но дольше, поэтому я решил выдать больше времени на центральную оптимизацию) и центральная оптимизация с meet-in-the-middle$(kL=15, kR=30)$. Среди всех подходов берётся лучший.
	\end{itemize}

	\textbf{id посылки} --- 49864540.
\end{document}
